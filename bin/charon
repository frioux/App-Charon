#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long::Descriptive;
use IO::Async::Loop;
use Net::Async::HTTP::Server::PSGI;
use IO::All;
use Future;

use App::Charon::Web;

my ($opt, $usage) = describe_options(
  'charon %o [file|dir]',
  [ 'listen|l=s',   "Listens on an address, whether HOST:PORT or :PORT"],
  [ 'autoshutdown=s', 'Shutdown after a given time period (example: 1h30m)'],
  [ 'query-param-auth=s', 'Use query param auth.  Eg: pass=station will require ?pass=station in requests'],
  [],
  [ 'help',       "print usage message and exit" ],
);

print($usage->text), exit if $opt->help;

my $loop = IO::Async::Loop->new;

my $quit = $loop->new_future;

my $app = App::Charon::Web->new(
   quit => $quit,
   (
      $ARGV[0] ? (root => $ARGV[0]) : ()
   ),
   (
      defined $opt->query_param_auth
         ? (query_param_auth => $opt->query_param_auth)
         : ()
   )
);
my $handler = Net::Async::HTTP::Server::PSGI->new(
   app => $app->to_psgi_app,
);
$loop->add($handler);

my $host = '0.0.0.0';
my $port;

if ($opt->listen and ($host, $port) = $opt->listen =~ m/^(.*):(\d+)$/) {
   $host = '0.0.0.0' if $host eq '*' || $host eq '';
}

$port ||= 5000;

$handler->listen(
   host => $host,
   service => $port,
   socktype => 'stream',
   on_listen_error => sub { die $_[1] },
   on_resolve_error => sub { die $_[1] },
   on_listen => sub {
      warn 'serving ' . io->file($app->_root)->rel2abs . ' on ' .
         $_[0]->read_handle->sockhost . ':' .
         $_[0]->read_handle->sockport .
         (
            @{$app->_query_param_auth}
               ? ' with a query param auth of ?'.
                  $app->_query_param_auth->[0] . '=' .
                  $app->_query_param_auth->[1]
               : ''
         ) .
         "\n"
   },
);

if (my $t = $opt->autoshutdown) {
   require Time::Duration::Parse;
   $quit = Future->wait_any(
      $quit,
      $loop->delay_future(
         after => Time::Duration::Parse::parse_duration($t),
      ),
   );
}

$quit->get;
