#!/usr/bin/env perl

use strict;
use warnings;

use Getopt::Long::Descriptive;
use IO::Async::Loop;
use Net::Async::HTTP::Server::PSGI;
use IO::All;
use Future;
use IO::Socket::IP;
use IO::Async::SSL;
use IO::Async::SSLStream;
use Capture::Tiny 'capture';

use App::Charon::Web;

my ($opt, $usage) = describe_options(
  'charon %o [file|dir]',
  [ 'listen|l=s',   "Listens on an address, whether HOST:PORT or :PORT"],
  [ 'autoshutdown=s', 'Shutdown after a given time period (example: 1h30m)'],
  [ 'query-param-auth=s', 'Use query param auth.  Eg: pass=station will require ?pass=station in requests'],
  [ 'index!', 'Show index (default on)', { default => 1 }],
  [],
  [ 'ssl-cert-file=s', 'a'],
  [ 'ssl-key-file=s', 'b'],
  [],
  [ 'help',       "print usage message and exit" ],
);

print($usage->text), exit if $opt->help;

my $loop = IO::Async::Loop->new;

my $quit = $loop->new_future;

my $app = App::Charon::Web->new(
   quit => $quit,
   (
      $ARGV[0] ? (root => $ARGV[0]) : ()
   ),
   (
      defined $opt->query_param_auth
         ? (query_param_auth => $opt->query_param_auth)
         : ()
   ),
   show_index => $opt->index,
);
my $handler = Net::Async::HTTP::Server::PSGI->new(
   extensions => ['SSL'],
   app => $app->to_psgi_app,
);
$loop->add($handler);

my $host = '0.0.0.0';
my $port;

if ($opt->listen and ($host, $port) = $opt->listen =~ m/^(.*):(\d+)$/) {
   $host = '0.0.0.0' if $host eq '*' || $host eq '';
}

my $sock;

if ($port) {
   $sock = IO::Socket::IP->new(
      LocalHost => $host,
      LocalService => $port,
      Listen => 1,
   )
} else {
   for my $port (3000..9999) {
      last if $sock = IO::Socket::IP->new(
         LocalHost => $host,
         LocalService => $port,
         Listen => 1,
      )
   }
   die "could not listen on any port!\n" unless $sock;
}

unlink $_ for qw(key foo.pem);
system('openssl genrsa -out key 4096');
system('openssl req -x509 -new -nodes -key key -days 365 -subj "/CN=localhost" -out foo.pem');
$handler->set_handle(
   $loop->SSL_upgrade(
      handle => $sock,
      SSL_server => 1,
      SSL_key_file => 'key',
      SSL_cert_file => 'foo.pem',
   )->get # or die "failed to upgrade: $SSL_ERROR";
);

warn 'serving ' . io->file($app->_root)->rel2abs . ' on ' .
   $sock->sockhost . ':' .
   $sock->sockport .
   (
      @{$app->_query_param_auth}
         ? ' with a query param auth of ?'.
            $app->_query_param_auth->[0] . '=' .
            $app->_query_param_auth->[1]
         : ''
   ) .
   "\n";

if (my $t = $opt->autoshutdown) {
   require Time::Duration::Parse;
   $quit = Future->wait_any(
      $quit,
      $loop->delay_future(
         after => Time::Duration::Parse::parse_duration($t),
      ),
   );
}

$quit->get;

__END__

   --http-auth [:genpass:] [password]
   --https [:genkeys:]
